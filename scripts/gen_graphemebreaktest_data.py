BREAK_CHAR = 'รท'
NOBREAK_CHAR = 'ร'
COMMENT_CHAR = '#'
ENDTEST_CHAR = '\t'


class GraphemeBreakTest:
    def __init__(self, test_name, codepoints, clusters):
        self.test_name = test_name
        self.codepoints = codepoints
        self.clusters = clusters


def get_tests():
    tests = []
    with open('GraphemeBreakTest.txt', 'r', encoding='utf-8') as gpt_file:
        lines = gpt_file.readlines()
        test_names = []
        for line in lines:
            if line.startswith(COMMENT_CHAR) or not line:
                continue
            test, name = line.split(ENDTEST_CHAR)
            test_parts = test.split()
            test_name = name[1:-1].strip()

            # Create name that is valid for google test
            test_name = test_name.replace(NOBREAK_CHAR, 'x')
            test_name = test_name.replace(BREAK_CHAR, 'o')
            test_name = test_name.replace(' ', '_')
            test_name = ''.join(c for c in test_name if c.isalnum())
            if test_name in test_names:
                continue
            test_names.append(test_name)

            # The break char prefix/suffix can be ignored as we only care about the differences within chars
            test_parts = test_parts[1:-1]

            codepoints = []
            clusters = [[],]
            for part in test_parts:
                if part != BREAK_CHAR and part != NOBREAK_CHAR:
                    codepoint = int(part, base=16)
                    codepoints.append(codepoint)
                    clusters[-1].append(codepoint)
                elif part == BREAK_CHAR:
                    clusters.append([])

            tests.append(GraphemeBreakTest(test_name, codepoints, clusters))
    return tests


def get_cpp_unordermap_data(props):
    start_header_data = \
        '// NOTE: This file was autogenerated via ' \
        'scripts/gen_graphemebreaktest_data.py\n' \
        '#pragma once\n\n' \
        '#include <vector>\n\n' \
        '#include <string>\n\n' \
        '#include <auc/codepoint.hpp>\n\n' \
        '// https://www.unicode.org/' \
        'Public/15.0.0/ucd/auxiliary/GraphemeBreakTest.txt\n'\
        'namespace auc {\n' \
        'namespace detail {\n\n' \
        'struct grapheme_cluster_break_test {\n' \
        '   std::string name_;\n' \
        '   std::vector<codepoint> codepoints_;\n'\
        '   std::vector<std::vector<codepoint>> clusters_;\n' \
        '};\n\n' \
        'static std::vector<grapheme_cluster_break_test> ' \
        'grapheme_cluster_break_tests = {\n'

    header_data = ''
    for prop_idx, prop in enumerate(props):
        header_data += '{'
        header_data += f'"{prop.test_name}", '

        header_data += '{'
        for codepoint_idx, codepoint in enumerate(prop.codepoints):
            header_data += f'{codepoint}u'
            if codepoint_idx < len(prop.codepoints) - 1:
                header_data += ', '
        header_data += '}, '

        header_data += '{'
        clusters = prop.clusters
        for cluster_idx, cluster in enumerate(prop.clusters):
            header_data += '{'
            cluster = clusters[cluster_idx]
            for cluster_codepoint_idx, cluster_codepoint in enumerate(cluster):
                header_data += f'{cluster_codepoint}u'
                if cluster_codepoint_idx < len(cluster) - 1:
                    header_data += ', '
            header_data += '}'
            if cluster_idx < len(prop.clusters) - 1:
                header_data += ', '
        header_data += '}}'

        if prop_idx < len(props) - 1:
            header_data += ',\n'

    end_header_data = \
        '\n};\n\n' \
        '} // namespace detail\n' \
        '} // namespace auc\n'

    return f'{start_header_data}{header_data}{end_header_data}'


cpp_header = get_cpp_unordermap_data(get_tests())
with open('../test/graphemebreaktest_data.hpp', 'w') as gen_header_file:
    gen_header_file.write(cpp_header)
