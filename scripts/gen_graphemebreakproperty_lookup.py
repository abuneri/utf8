PROP_CPP_CONV = {
    'CR': 'property::CR',
    'LF': 'property::LF',
    'Control': 'property::Control',
    'Extend': 'property::Extend',
    'Regional_Indicator': 'property::RI',
    'Prepend': 'property::Prepend',
    'SpacingMark': 'property::SpacingMark',
    'L': 'property::L',
    'V': 'property::V',
    'T': 'property::T',
    'LV': 'property::LV',
    'LVT': 'property::LVT',
    'ZWJ': 'property::ZWJ'
}


class GraphemeBreakProperty:
    def __init__(self, codepoint, prop_type):
        self.codepoint = codepoint
        self.prop_type = PROP_CPP_CONV[prop_type]


def codepoint_range(codepoint):
    if '..' in codepoint:
        start = 0
        end = 0

        if len(codepoint) == 10:
            # U+XXXX
            start = int(codepoint[0:4], base=16)
            end = int(codepoint[6:10], base=16)
        elif len(codepoint) == 12:
            # U+XXXXX
            start = int(codepoint[0:5], base=16)
            end = int(codepoint[7:12], base=16)

        if start == end or start > end:
            return None

        return [cp for cp in range(start, end + 1)]
    else:
        return [int(codepoint, base=16)]


def get_properties():
    props = []
    with open('GraphemeBreakProperty.txt', 'r', encoding='utf-8') as gpb_file:
        lines = gpb_file.readlines()
        for line in lines:
            if line.startswith('#') or not line:
                continue
            first_section = line.split(';')
            if len(first_section) != 2:
                continue

            codepoint = first_section[0].strip()
            codepoints = codepoint_range(codepoint)
            if codepoints is None:
                continue

            second_section = first_section[1].split('#')
            if len(second_section) != 2:
                continue

            prop_type = second_section[0].strip()
            for cp in codepoints:
                props.append(GraphemeBreakProperty(cp, prop_type))

    return props


def get_cpp_unordermap_data(props):
    start_header_data = \
        '// NOTE: This file was autogenerated via ' \
        'scripts/gen_graphemebreakproperty_lookup.py\n' \
        '#pragma once\n\n' \
        '#include <unordered_map>\n\n' \
        '#include <auc/codepoint.hpp>\n\n' \
        '// https://www.unicode.org/' \
        'Public/15.0.0/ucd/auxiliary/GraphemeBreakProperty.txt\n'\
        'namespace auc {\n' \
        'namespace detail {\n\n' \
        'enum class property : int {\n' \
        '   Other = 0,\n' \
        '   CR = 1,\n' \
        '   LF = 2,\n' \
        '   Control = 3,\n' \
        '   Extend = 4,\n' \
        '   RI = 5,\n' \
        '   Prepend = 6,\n' \
        '   SpacingMark = 7,\n' \
        '   L = 8,\n' \
        '   V = 9,\n' \
        '   T = 10,\n' \
        '   LV = 11,\n' \
        '   LVT = 12,\n' \
        '   ZWJ = 13\n' \
        '};\n\n' \
        'struct grapheme_cluster_break {\n' \
        '   codepoint codepoint_{0};\n'\
        '   property prop_{property::Other};\n' \
        '};\n\n' \
        'static std::unordered_map<std::uint32_t, grapheme_cluster_break> ' \
        'codepoint_break_lookup = {\n'

    header_data = ''
    num_props = len(props)
    for prop_idx in range(num_props):
        prop = props[prop_idx]
        header_data += \
            f'  {{{prop.codepoint}, {{{prop.codepoint}, {prop.prop_type}}}}}'
        if prop_idx < num_props - 1:
            header_data += ',\n'

    end_header_data = \
        '\n};\n\n' \
        '} // namespace detail\n' \
        '} // namespace auc\n'

    return f'{start_header_data}{header_data}{end_header_data}'


cpp_header = get_cpp_unordermap_data(get_properties())
with open('../src/graphemebreakproperty_lookup.hpp', 'w') as gen_header_file:
    gen_header_file.write(cpp_header)
